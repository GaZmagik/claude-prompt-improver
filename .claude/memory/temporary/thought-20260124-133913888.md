---
type: breadcrumb
title: "Think: v1.6.0 pluginResources feature incomplete - wiring gap investigation"
topic: v1.6.0 pluginResources feature incomplete - wiring gap investigation
status: concluded
created: "2026-01-24T13:39:13.891Z"
updated: "2026-01-24T13:44:44.080Z"
tags:
  - think
  - concluded
scope: project
conclusion: "v1.6.0 pluginResources wiring gap: The feature was implemented in context-builder.ts but never wired into improve-prompt.ts. Four missing integration points identified: (1) hasIntegrations check doesn't include pluginResources, (2) contextInput building never adds pluginResourcesOptions, (3) hasAnyContext check ignores pluginResources, (4) improvementContext mapping exists but receives nothing. Root cause: pluginResources was treated as a config-driven toggle when it's actually discovery-driven infrastructure. Fix: unconditionally wire pluginResources into improve-prompt.ts as mandatory formatting, add integration tests that validate end-to-end flow, update docs to match actual functionality."
promotedTo: gotcha-v1-6-0-pluginresources-feature-incomplete-wiring-g
---

# v1.6.0 pluginResources feature incomplete - wiring gap investigation

_Thinking document created 2026-01-24T13:39:13.891Z_

## Thoughts

### 2026-01-24T13:39:23.725Z - Thought
Initial framing: The v1.6.0 PR claimed structured resource discovery with pluginResources (language detection, Speckit status, plugins, MCP servers). The feature was implemented in context-builder.ts and resource-formatter.ts, but improve-prompt.ts never wires it through. Users see improved prompts but no <tools>, <skills>, <agents>, or <project-context> XML sections.

### 2026-01-24T13:41:57.369Z - Thought (model:haiku agent:typescript-expert [62f5ae9b-81a0-470f-932f-bf10fc1bb841])
The wiring gap isn't just incomplete—it's a multi-layered failure of orchestration that reveals architectural confusion about where pluginResources should live in the flow.

**Layer 1: The hasIntegrations Logic (improve-prompt.ts:274-277)** — This is the critical false negative. When checking if we have any context worth gathering, the function never references pluginResources. It explicitly checks git, lsp, spec, memory, and session integrations in the config object, but pluginResources is never enabled through config toggles. It exists only as an option in context-builder, but improve-prompt has no pathway to enable it. This is a logical disconnect: context-builder treats pluginResources as an async context option (like git, lsp, etc.), but improve-prompt only wires integrations from config—and config likely never includes a pluginResources toggle because there's no config schema for it.

**Layer 2: The contextInput Building Gap (improve-prompt.ts:284-326)** — Once hasIntegrations passes, contextInput is populated with options. The function correctly maps every integration toggle from config into its corresponding context option. But pluginResources has no config toggle to map. Even though context-builder accepts `pluginResourcesOptions` as a parameter (line 137 of context-builder.ts), improve-prompt never provides it. The wiring skips from config checks directly to context-builder, leaving pluginResources orphaned.

**Layer 3: The hasAnyContext Detection Failure (improve-prompt.ts:332-334)** — The formattedContext check searches for tools, skills, agents, and various integrations—but pluginResources is conspicuously absent. This means even if pluginResources were somehow gathered (which it isn't, because contextInput never enables it), the formatted result would still be invisible. The early return would still trigger, discarding the entire ImprovementContext.

**Layer 4: The improvementContext Mapping (improve-prompt.ts:340-370)** — Although this section does include pluginResources at line 366-368, it's defensive code: it attempts to map something that will never exist because upstream logic never gathered it.

**Root Cause**: pluginResources exists in context-builder as a first-class async context option, but improve-prompt never activates it. It's not wired through config toggles, not checked in hasIntegrations, not passed through contextInput, and not validated in hasAnyContext. The feature was implemented in isolation without the orchestration glue that connects configuration → enablement → gathering → validation → injection.

### 2026-01-24T13:42:21.749Z - Counter-argument (model:haiku style:Sardonic agent:code-quality-expert [15a2cf63-e1c2-4208-a7c7-bf580bd7cf38])
The architectural inconsistency isn't actually a flaw—it's a symptom of pluginResources being fundamentally different from the other integrations. Those toggles control *whether* to include standard, predictable metadata. pluginResources is *discovery-driven*, not configuration-driven. You can't toggle whether to discover languages or detect Speckit status the same way you toggle whether to include git history or terminal output.

The real problem isn't that pluginResources lives outside IntegrationToggles. The real problem is that improve-prompt.ts doesn't *call* context-builder.ts at all. It's not an architectural inconsistency—it's a missing dependency. improve-prompt.ts still manually constructs the prompt using the old approach (buildContextLines) instead of delegating to context-builder, which is where all the orchestration logic actually lives.

If you look at it this way, the feature *was* implemented correctly in the right places. context-builder.ts properly discovers and formats resources. The mistake was thinking improve-prompt.ts would magically know to use it. Nobody wired the caller to the implementation. That's not an architecture problem; that's a scaffolding problem—a forgotten integration point during refactoring.

The toggles inconsistency is almost irrelevant. The real architectural debt is that improve-prompt.ts is still the monolithic entry point that doesn't delegate to the modular context-builder. Fixing that single callsite would surface pluginResources everywhere the system expects improved prompts, without needing to retrofit toggles or restructure the resource discovery layer.

### 2026-01-24T13:42:46.428Z - Thought (model:haiku style:Sardonic agent:test-quality-expert [b6c452a6-df5f-4a3b-a837-81b322dfc53a])
Testing failure here reveals a classic gap: improve-prompt.ts has tests for *output shape* (does it produce the right XML structure?), but those tests never exercise the actual resource discovery flow. The tests likely mock or stub out the context-builder entirely, checking that "when contextBuilder returns X, improve-prompt formats it as Y"—without ever validating that X actually contains pluginResources data.

This is a coverage cheat dressed up as unit testing discipline. The tests pass because they're testing improve-prompt's ability to format whatever it receives, not its ability to wire correctly. There's probably a test saying "formats plugin resources correctly" that uses a fixture with pre-baked pluginResources data, never hitting the actual context-builder.getPluginResources() call path.

The real issue: there are no *integration-layer tests* that say "when user runs improve-prompt, the full pipeline from context-builder discovery through resource formatting actually executes." Unit tests can't catch orchestration failures—they're too isolated. You need a test that:
1. Initializes improve-prompt with a real project context
2. Calls the full improve-prompt flow
3. Validates that the output XML *actually contains* discovered languages, Speckit status, plugins, MCP servers—not just the structure to hold them

The feature passed code review because reviewers trusted the unit tests, which were technically honest but strategically useless. This is why integration test parity matters: you can't discover wiring gaps with mocks and fixtures pretending the world is simpler than it is.

### 2026-01-24T13:43:11.174Z - Thought (model:haiku style:Sardonic agent:documentation-accuracy-expert [f699587d-646e-4202-b714-e7f91be83232])
The documentation gap compounds the implementation gap in a way that reveals how this feature was never truly validated end-to-end. If CHANGELOG and README claim "structured resource discovery with automatic XML injection of tools, skills, agents, and project context," but improve-prompt.ts has zero code paths that actually wire pluginResources into the final prompt, then the feature was shipped as aspirational documentation rather than working code.

This is worse than an incomplete implementation—it's a false promise. Users see the marketing ("v1.6.0: Automatic resource discovery!") but experience the reality (same old prompts, no XML sections). That gap between claim and delivery isn't just a testing failure; it suggests the feature was merged without anyone actually running the end-to-end flow with real pluginResources data and verifying the output.

The architectural confusion your counter-argument describes—that pluginResources is "discovery-driven, not configuration-driven"—actually points to the root problem: pluginResources was bolted onto a system designed around toggles and doesn't have a natural integration point. Rather than redesigning the flow to accommodate it, the implementation stopped at "build the discovery machinery" and never finished "integrate it into prompt generation." That's not an architectural elegance; that's an incomplete refactor that got released anyway.

The fix isn't just wiring improve-prompt.ts. It's also updating CHANGELOG and README to either accurately describe what works (remove the false promises) or commit to finishing the feature properly—including tests that prove pluginResources data flows end-to-end and actually appears in user prompts.

### 2026-01-24T13:43:36.754Z - Alternative (model:haiku style:Sardonic agent:typescript-expert [d23687ce-e374-47ad-9e4a-920113092600])
The minimal fix route is tempting but misses the actual problem. "Always enable resource discovery" sounds clean until you realize you're still not wiring the discovered resources *into the prompt*. You'd end up with pluginResources silently computed and discarded—which is exactly where we are now.

The real architectural issue: pluginResources lives in context-builder as a *computed object*, but improve-prompt treats the context parameter as a black box that it formats into XML. There's a categorical mismatch. context-builder says "here's structured data about your environment," and improve-prompt says "I'll turn whatever you gave me into XML tags."

The alternative worth exploring: make improve-prompt *query* for pluginResources rather than waiting for it to arrive in the context parameter. Instead of:

```
improve-prompt(context) → find pluginResources in context → inject into XML
```

Flip it:

```
improve-prompt(context) → needs pluginResources? → ask context-builder explicitly → inject into XML
```

This breaks the tight coupling. improve-prompt becomes responsible for deciding *when* it wants resource metadata, not context-builder deciding whether to compute it. The toggle system still works—you're just toggling at the point of consumption, not the point of production.

The cost: improve-prompt needs to know how to fetch pluginResources on demand. The benefit: you can't ship a feature where resources are "discovered" but never used. The discovery and injection become a single, testable unit.

But there's a third path worth considering: accept that pluginResources doesn't fit the toggle model because it's not a *feature flag*—it's *infrastructure*. Stop treating it like an optional enhancement and make it a first-class part of the context shape itself. Bake it into the context object's type definition so every context has a pluginResources field (even if some fields are empty). Now improve-prompt doesn't question whether resources exist; it just formats whatever's there.

This trades configuration flexibility for simplicity. You lose the ability to say "compute resources but don't include them in the prompt," but you gain the guarantee that if resources were computed, they're in the prompt. And you catch wiring gaps immediately because the type system enforces that context always carries resource data.

### 2026-01-24T13:44:01.048Z - Counter-argument (model:haiku style:Sardonic agent:security-code-expert [c0f9bf20-24d2-4b12-812c-3d89aca6e351])
The security fixation here is actually a red herring that distracts from the real architectural problem.

Yes, blindly injecting discovered plugin metadata into prompts *could* theoretically expose sensitive configuration—MCP server endpoints, plugin authentication tokens, internal tool descriptions that hint at infrastructure. Standard response: sanitise the output, don't include secrets, treat pluginResources like any other untrusted data source.

But that framing misses what's actually happening. The real issue isn't "how do we safely inject this data?" It's "why are we treating pluginResources discovery as something that happens *at prompt time* in improve-prompt.ts, rather than something that happens *at initialization time* in context-builder.ts?"

The tests and code patterns suggest an assumption that resource discovery is lightweight and repeatable—safe to do on every prompt improvement cycle. But if you're discovering MCP server connectivity, validating Speckit symlinks, scanning the plugin registry, and introspecting language tooling for every single prompt boost, you're either doing redundant work or you're caching results in a way that becomes stale.

The security concern that *should* exist is: what happens when a cached pluginResources snapshot becomes outdated? A user installs a new MCP server, but improve-prompt still references stale metadata. Or worse—improve-prompt references a plugin that was uninstalled, and the prompt now contains instructions for using tools that no longer exist. That's not a data sanitisation problem; it's a cache invalidation problem.

The wiring gap isn't incomplete because of architectural confusion about toggles versus discovery. It's incomplete because nobody decided whether pluginResources lives in the request context (computed fresh, always accurate, potentially expensive) or in cached, pre-computed metadata (fast, potentially stale, security-risk surface for outdated references). The "minimal fix" of always enabling it just kicks that decision down the road while creating the stale-reference vulnerability.

### 2026-01-24T13:44:25.088Z - Thought (model:haiku style:Sardonic agent:nodejs-expert [8798f8d8-94c2-4ccc-a9c1-3bfb1afe29c4])
The pragmatic fix is deceptively simple but reveals why this shipped broken: pluginResources needs to be *unconditionally* wired into improve-prompt.ts, not as a toggle option, but as a mandatory formatting step that happens *after* all the standard context is assembled.

Here's the thing—improve-prompt.ts already has the infrastructure to inject XML sections. It's building `<context>`, `<conversation>`, `<files>`, etc. The actual cost of adding `<tools>`, `<skills>`, `<agents>`, and `<project-context>` sections is approximately zero lines of code. You're not adding branching logic or conditional discovery. You're just saying: "After we've formatted everything else, if contextBuilder gave us pluginResources, format those sections too."

The wiring gap exists because someone treated pluginResources as "another optional context toggle" (like includeGitHistory), when it's actually "metadata that's always discovered, sometimes populated, always safe to format." Even if Speckit isn't present, or there are no MCP servers, the sections just won't have content—they won't break anything.

The minimal ship: 
1. In improve-prompt.ts, accept pluginResources from the context object
2. Add three simple formatters (one for each resource category) that consume pluginResources and output XML sections
3. Call those formatters unconditionally in the prompt assembly pipeline
4. Update the test mocks to include pluginResources in the mock context, even if it's empty

This isn't about debate or architectural refinement. It's about finishing what was started. The discovery code is working. The formatting code is working. The only missing piece is the six-line glue that connects them, and that piece was apparently never tested because nobody ever ran the full flow end-to-end before shipping.

### 2026-01-24T13:44:44.080Z - Conclusion
v1.6.0 pluginResources wiring gap: The feature was implemented in context-builder.ts but never wired into improve-prompt.ts. Four missing integration points identified: (1) hasIntegrations check doesn't include pluginResources, (2) contextInput building never adds pluginResourcesOptions, (3) hasAnyContext check ignores pluginResources, (4) improvementContext mapping exists but receives nothing. Root cause: pluginResources was treated as a config-driven toggle when it's actually discovery-driven infrastructure. Fix: unconditionally wire pluginResources into improve-prompt.ts as mandatory formatting, add integration tests that validate end-to-end flow, update docs to match actual functionality.
